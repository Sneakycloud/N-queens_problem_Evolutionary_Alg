import time
import sys


def avg_time_n_queens_solver(board_size_n, boards_per_generation,pop_init_alg, mutation_rate, max_generations, stall_limit, itererations, ignore_0_gen, n_queen_solver):
    """gets the average time to solve"""
    time_taken = []
    for i in range(itererations):
        start_time = time.process_time()
        solution_found = (n_queen_solver(board_size_n, boards_per_generation, mutation_rate, max_generations, stall_limit, pop_init_alg))
        end_time = time.process_time()
        
        #if to ignore board that have just been generated by pop_initilization and have not been affected by recombine, mutate, select
        if(ignore_0_gen and solution_found[1] == 0):
            continue
        #if a solution was found within time and the problem was not halted
        elif(solution_found[1] < max_generations and solution_found[2] < stall_limit):
            time_taken.append(end_time - start_time)
        #if a solution was not found
        else:
            time_taken.append(sys.maxsize // itererations)
    
    if(ignore_0_gen and len(time_taken) == 0):
        return 0
    elif(len(time_taken) > 0):        
        return sum(time_taken) / len(time_taken)
    else:
        #represents failing to find a single solution
        return sys.maxsize

def gen_size_tuner(board_size_n, boards_per_generation,pop_init_alg, mutation_rate, max_generations, stall_limit,stop_tolerence,itererations, n_queen_solver):
    """finds the most optimal value for gen_size assuming all other variables are static"""
    last_calibrated_gen_size = max_generations
    last_low_search_value = max_generations
    last_high_search_value = 2
    
    low_search_value = 2
    max_search_value = boards_per_generation
    high_search_value = max_search_value
    
    current_time_taken = 0
    half_time_taken = 0
    double_time_taken = 0
    
    def parameter_avg_time_n_queens_solver(gen_size):
        return avg_time_n_queens_solver(board_size_n, gen_size,pop_init_alg, mutation_rate, max_generations, stall_limit, itererations, False, n_queen_solver)
    
    #finds lowest value for low_search where all iterations of low_search succeed
    is_successfull = False
    while not is_successfull:
        print(f"Testing lowest search value of {low_search_value}")
        is_successfull = True
        for _ in range(itererations):
            solution_found = (n_queen_solver(board_size_n, low_search_value, mutation_rate, max_generations, stall_limit, pop_init_alg))
            
            if not (solution_found[1] < max_generations and solution_found[2] < stall_limit):
                low_search_value *= 2
                is_successfull = False
                break
            
    print(f"Found lowest all successful lowest search value: {low_search_value}")
    if(low_search_value > high_search_value):
        high_search_value = low_search_value*2
    
    calibrated_gen_size = (low_search_value + high_search_value) // 2
    print(f"Calculating initial board of {calibrated_gen_size} ")
    current_time_taken = parameter_avg_time_n_queens_solver(calibrated_gen_size)
    
    #finds a local minimum in time taken for board sizes through a binary search
    while low_search_value != high_search_value:
        print(f"boards per generations now testing: {low_search_value}, {calibrated_gen_size}, {high_search_value}")
        
        #tests if the last value was just tested. This is to avoid the function bouceing between two values
        if(abs(max(calibrated_gen_size, low_search_value, high_search_value) - min(calibrated_gen_size, low_search_value, high_search_value)) < 2 or abs(max(current_time_taken, half_time_taken, double_time_taken) - min (current_time_taken, half_time_taken, double_time_taken)) < stop_tolerence):
            break
        
        #Check half the value
        if(last_low_search_value != low_search_value):
            half_time_taken = parameter_avg_time_n_queens_solver(low_search_value)
        
        #Check if we need to update the current value
        if(last_calibrated_gen_size != calibrated_gen_size):
            current_time_taken = parameter_avg_time_n_queens_solver(calibrated_gen_size)
        
        #Check double the value
        if(last_high_search_value != high_search_value):
            double_time_taken = parameter_avg_time_n_queens_solver(high_search_value)
        
        last_low_search_value = low_search_value
        last_high_search_value = high_search_value
        last_calibrated_gen_size = calibrated_gen_size
        
        print(f"Time taken {round(half_time_taken, 4)} {round(current_time_taken, 4)} {round(double_time_taken, 4)}")
        
        #Adjust based on if the half, current or double lead to the best result
        if half_time_taken == min(current_time_taken, half_time_taken, double_time_taken):
            high_search_value = calibrated_gen_size
            double_time_taken = current_time_taken
            calibrated_gen_size = (low_search_value + high_search_value) // 2
            
            #since the current value becomes the new high_search value we want to avoid calculating it again
            last_high_search_value = high_search_value
        elif double_time_taken == min(current_time_taken, half_time_taken, double_time_taken) :
            low_search_value = calibrated_gen_size
            half_time_taken = current_time_taken
            calibrated_gen_size = (low_search_value + high_search_value) // 2
            
            #since the current value becomes the new low_search value we want to avoid calculating it again
            last_low_search_value = low_search_value
        elif current_time_taken == min(current_time_taken, half_time_taken, double_time_taken):
            high_search_value = (calibrated_gen_size + high_search_value) // 2
            low_search_value = (calibrated_gen_size + low_search_value) // 2
        
        if high_search_value == calibrated_gen_size or low_search_value == calibrated_gen_size and high_search_value == max_search_value:
            high_search_value = max_search_value*10
            low_search_value = max_search_value
            calibrated_gen_size = (high_search_value + low_search_value) // 2
            max_search_value *= 10
        
            
            
    print(f"Optimal boards per generations: {calibrated_gen_size}")
    return calibrated_gen_size
  

def mutation_rate_tuner(board_size_n, boards_per_generation,pop_init_alg, mutation_rate, max_generations, stall_limit,stop_tolerence,itererations, n_queen_solver):
    #test all values of 10, 20, 30, ... ,90, 100
    calibrated_mutation_rate = 0
    
    avg_times = []
    
    def parameter_avg_time_n_queens_solver(new_mutation_rate):
        return avg_time_n_queens_solver(board_size_n, boards_per_generation,pop_init_alg, new_mutation_rate, max_generations, stall_limit, itererations, True , n_queen_solver)
    
    print("Now checking 10:ths mutation rates")
    for new_mutation_rate in range(0,101,10):
        print(f"Now checking {new_mutation_rate}")
        avg_time = parameter_avg_time_n_queens_solver(new_mutation_rate)
        avg_times.append((new_mutation_rate, avg_time))
    
    #find the smallest value average time for the 10:ths mutation rates
    fastest_mutation_rate = min(avg_times, key=lambda t: t[1])
    print(f"Fastest 10:ths mutation rate is {fastest_mutation_rate[0]} with an avg time of {fastest_mutation_rate[1]} s")
    avg_times = [fastest_mutation_rate]
    
    #check all values -5 from that value
    if fastest_mutation_rate[0] > 0:
        for new_mutation_rate in range(fastest_mutation_rate[0]-5, fastest_mutation_rate[0]):
            print(f"Now checking {new_mutation_rate}")
            avg_time = parameter_avg_time_n_queens_solver(new_mutation_rate)
            avg_times.append((new_mutation_rate, avg_time))
        
    print("Checked -5 values")
        
    #check all values +5 from that value
    if fastest_mutation_rate[0] < 100:
        for new_mutation_rate in range(fastest_mutation_rate[0]+1, fastest_mutation_rate[0]+6):
            print(f"Now checking {new_mutation_rate}")
            avg_time = parameter_avg_time_n_queens_solver(new_mutation_rate)
            avg_times.append((new_mutation_rate, avg_time))
        
    print("Checked +5 values")
        
    #find the smallest value average time for the 10:ths mutation rates
    fastest_mutation_rate = min(avg_times, key=lambda t: t[1])
    
    print(f"Fastest mutation rate is {fastest_mutation_rate[0]} with an avg time of {fastest_mutation_rate[1]} s")
    
    return fastest_mutation_rate[0]